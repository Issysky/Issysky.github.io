(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{412:function(t,e,n){t.exports=n.p+"assets/img/2.31fb84f8.png"},435:function(t,e,n){"use strict";n.r(e);var r=n(2),o=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"题目"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#题目"}},[t._v("#")]),t._v(" 题目")]),t._v(" "),e("p",[t._v("给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点 是指没有子节点的节点。")]),t._v(" "),e("img",{attrs:{src:n(412)}}),t._v("\n### 解法\n看到树，应该第一时间可以想到递归解决，因为树不是很好遍历。本题就是递归深度优先搜索，然后用了链表去存放数据。\n```java\nclass Solution {\n    LinkedList"),e("Integer",[t._v("> res = new LinkedList<>();\n    LinkedList"),e("Integer",[t._v(" path = new LinkedList<>(); \n    public List"),e("Integer",[t._v("> pathSum(TreeNode root, int sum) {\n        recur(root, sum);\n        return res;\n    }\n    void recur(TreeNode root, int tar) {\n        if(root == null) return;\n        path.add(root.val);\n        tar -= root.val;\n        if(tar == 0 && root.left == null && root.right == null)\n            res.add(new LinkedList(path));//注意这里不能直接return，不然下面就不会继续回溯了\n        recur(root.left, tar);\n        recur(root.right, tar);\n        path.removeLast();//这一步是为了回溯\n    }\n}\n"),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[面试题34. 二叉树中和为某一值的路径（回溯法，清晰图解） - 二叉树中和为某一值的路径 - 力扣（LeetCode）](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/)\n")])])])])],1)],1)],1)}),[],!1,null,null,null);e.default=o.exports}}]);