(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{431:function(v,_,t){"use strict";t.r(_);var i=t(2),s=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("函数简写")]),v._v(" "),_("ul",[_("li",[v._v("无参数："),_("code",[v._v("() => {}")])]),v._v(" "),_("li",[v._v("单个参数："),_("code",[v._v("x => {}")])]),v._v(" "),_("li",[v._v("多个参数："),_("code",[v._v("(x, y) => {}")])]),v._v(" "),_("li",[v._v("解构参数："),_("code",[v._v("({x, y}) => {}")])]),v._v(" "),_("li",[v._v("嵌套使用：部署管道机制")]),v._v(" "),_("li",[v._v("this指向固定化\n"),_("ul",[_("li",[v._v("并非因为内部有绑定"),_("code",[v._v("this")]),v._v("的机制，而是根本没有自己的"),_("code",[v._v("this")]),v._v("，导致内部的"),_("code",[v._v("this")]),v._v("就是外层代码块的"),_("code",[v._v("this")])]),v._v(" "),_("li",[v._v("因为没有"),_("code",[v._v("this")]),v._v("，因此不能用作构造函数")])])])]),v._v(" "),_("p",[_("em",[v._v("tips")]),v._v(" ：")]),v._v(" "),_("ol",[_("li",[v._v("箭头函数的this"),_("code",[v._v("是静态的")]),v._v("，"),_("code",[v._v("始终指向函数声明时所在作用域下的this")]),v._v("的值；")]),v._v(" "),_("li",[v._v("不能作为构造实例化对象；")]),v._v(" "),_("li",[v._v("不能使用 arguments 变量；")])]),v._v(" "),_("p",[v._v("为什么说箭头函数不用担心this指向\n因为：函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象\n正常的函数如果被用做赋值，this的指向会随之改变为被赋值的对象，箭头函数避免了这个问题")])])}),[],!1,null,null,null);_.default=s.exports}}]);