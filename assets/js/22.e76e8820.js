(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{428:function(e,t,a){"use strict";a.r(t);var s=a(2),n=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h4",{attrs:{id:"map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[e._v("#")]),e._v(" map")]),e._v(" "),t("p",[e._v("map是键值对的集合：")]),e._v(" "),t("ul",[t("li",[e._v("允许任何类型的键")]),e._v(" "),t("li",[e._v("具有极快的查找速度")]),e._v(" "),t("li",[e._v("不适用于存储数量很多的键值对")])]),e._v(" "),t("p",[t("strong",[e._v("方法和属性")]),e._v("\nnew Map() —— 创建 map。\nmap.set(key, value) —— 根据键存储值。\nmap.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。\nmap.has(key) —— 如果 key 存在则返回 true，否则返回 false。\nmap.delete(key) —— 删除指定键的值。\nmap.clear() —— 清空 map。\nmap.size —— 返回当前元素个数。\n"),t("strong",[e._v("WeakMap")]),e._v("\n是一组键值对的集合，其中的键是弱引用对象，而值可以是任意")]),e._v(" "),t("ul",[t("li",[e._v("只接受对象作为健名")]),e._v(" "),t("li",[e._v("键名弱引用，可以被垃圾回收")]),e._v(" "),t("li",[e._v("不可遍历")]),e._v(" "),t("li",[e._v("Api和Map相同")])]),e._v(" "),t("h4",{attrs:{id:"set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[e._v("#")]),e._v(" set")]),e._v(" "),t("p",[e._v("set是一组Key的集合，但是不存储Value，由于Key不能重复，因此他最大的特点是"),t("strong",[e._v("所有的元素都是唯一的")]),e._v("。")]),e._v(" "),t("p",[t("strong",[e._v("方法和属性")]),e._v("\nnew Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里- 面复制值到 set 中。\nset.add(value) —— 添加一个值，返回 set 本身\nset.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。\nset.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。\nset.clear() —— 清空 set。\nset.size —— 返回元素个数。\n"),t("strong",[e._v("weakset")]),e._v("\n只接受对象作为成员，且成员都是弱引用")])])}),[],!1,null,null,null);t.default=n.exports}}]);